\documentclass{article}
%\usepackage[austrian]{babel}

\input{epsf}

\usepackage{graphicx}

\usepackage[utf8]{inputenc}
\usepackage{amsmath}

% generic packages needed for math and logic symbols
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{wasysym}
\usepackage{mathrsfs}
\usepackage{array}
\usepackage{xcolor}

%% for logical symbols 
\input{macros.tex}

%for the algorithm showing
\usepackage{algorithm}
\usepackage{algpseudocode}

% to add links to external resources
\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=blue,    
    citecolor=black
}

%to list code in the document
\usepackage{listings}
\usepackage{xcolor}

%% bibliography management
\usepackage[backend=biber,style=numeric,sorting=ydnt]{biblatex}
\addbibresource{biblio.bib} %Import the bibliography file

%% to add todonotes
\usepackage{todonotes}

\newcommand\inParens[1]{\texttt{(}#1\texttt{)}}
\newcommand\inBraces[1]{\texttt{\{}#1\texttt{\}}}
\newcommand\comma{\texttt{,}}
\newcommand\semicolon{\texttt{;}}

\title{Model Checking ``MiniCheck''}

\setlength{\oddsidemargin}{0mm}
\setlength{\evensidemargin}{0mm}
\setlength{\topmargin}{-1cm}
\setlength{\textheight}{22.5cm}
\setlength{\textwidth}{15cm}

%\newcommand{\Nat}{\mbox{I\hspace{-0.1em}N}}
\newcommand{\Nat}{\ifmmode{\sf I\hspace*{-0.3mm}N} \else\mbox{${\sf I\hspace*{-0.3mm}N$}}\fi}
\newcommand{\nat}{\Nat}
\newcommand{\Reell}{\ifmmode{\sf I\hspace*{-0.3mm}R} \else\mbox{${\sf I\hspace*{-0.3mm}R$}}\fi}
\newcommand{\comment}[1]{}
\newcommand{\eqdef}{\mbox{$=_{df}\,$}}

\newcommand{\assnumber}{5}

\pagestyle{empty}

\begin{document}
\large
\thispagestyle{empty}
\begin{center}
  {\Large \textbf{185.A05 Advanced Functional Programming SS 22}}  \\ [1ex] 
            Monday, 05/02/2022 \\
               {\Large \textbf{Assignment 5}} \\[.5ex]
              {\Large \textbf{Model Checking Project: MiniCheck}} \\[.5ex]
                 \textbf{All Chapters}  \\ [.75ex]
           \textbf{Topic:} Building a CTL Model Checker plus Implementing a Choice of Modelling/Verification Extensions  \\[1ex]
          \textbf{Submission deadline:} Friday, 06/13/2022, noon (no second submission)  \\ [0.5ex]
          \textbf{Contact:} Samuel Pilz, samuel.pilz@student.tuwien.ac.at, 
                            Francesco Pontiggia, francesco.pontiggia@tuwien.ac.at 
%          (In case of need, this deadline will be extended (details posted via TISS))
\end{center}

\vspace{1ex}
\noindent
\noindent

%\title{Programming Project ``MINI''}


%\maketitle


\newcommand{\code}[1]{\texttt{#1}}

\noindent
The goal of the project is to implement a Computational Tree Logic (CTL) Model Checker, \textit{MiniCheck}. 
The project consists of two parts: the core model checker and the elective modular extensions. 
In turn, the core model checker requires resp.: 
\begin{itemize}
    \item a number of preliminary programming tasks (\textbf{Module 0}, cf.~Section \ref{subsec-ts} and \ref{subsec-ctl}).
    \item a verification module which checks the input CTL formula on a Transition System (TS)(\textbf{Module 1}, cf.~Section \ref{subsec-mca} and \ref{subsec-m1}).

\end{itemize}  
The core is mandatory but is only worth a portion of the points achievable in this project.

In contrast to previous exercises, you are not asked to implement functions with given signatures. 
Instead, the functionality of the executed program is evaluated. 
You will have to design your own function signatures and data types and decide 
which data structures you want to use.

The program should not be written in a single file, but as a \href{https://docs.haskellstack.org/en/stable/README/}{\code{stack}} 
or \href{https://cabal.readthedocs.io/en/3.4/}{\code{cabal}} project consisting of multiple modules. 
It is encouraged to use custom and predefined data structures, as well as external libraries 
and Haskell language extensions \textbf{where appropriate}. It is not required to get the project to run on g0.

There will be a Q\&A session where help will be provided in case there are troubles with the selected technologies. 
The date will be announced via TUWEL news.

\section{Grading}

The preliminary programming tasks with a parser at its core (\textbf{Module 0}) and 
the verification module (\textbf{Module 1}) of MiniCheck are mandatory. 
Implementing this core awards up to 200 points. The project presentation will be worth up to 100 points. 
To gain more points on top of the aforementioned, you can choose from some modelling 
and verification extensions of the MiniCheck tool.

For a positive evaluation of this project at least 200 points are required. 
A positive grade on the project is necessary in order to receive a positive grade in this course. 
The total points for the project are calculated by adding up the points on the core, 
the selected extensions and the submission talk. A positive grade on the core itself is \textit{not} required. 
At most 300 points are awarded for the project implementation.

In contrast to previous exercises, there is no second submission.

\subsection{Note}
We assume a general knowledge of model checking and its purpose, as well as basis of logics,
such as propositional logic.  Besides this, some previous knowledge in related fields helps 
and makes the project smaller, but it's not mandatory. This includes also:
\begin{itemize}
    \item Automata Theory
    \item Graph Algorithms
\end{itemize}
See, e.g., \cite{BaKa} for details (a PDF version is available on the 
\href{https://github.com/francescopont/MiniCheck.git}{Github repository}).

\section{MiniCheck Core (200P)}

Model Checking consists of formally and exhaustively verifying a formula 
against all the possible executions of a particular type of automata. 
In the following, we provide some preliminary information 
about the type the formalisms you are required to support, 
and then present the project to carry out. 
For a complete and deeper introduction to our approach in model checking, 
please, refer to \cite{BaKa} (a PDF version is available on the 
\href{https://github.com/francescopont/MiniCheck.git}{Github repository}).


\subsection{Preliminaries - Transition Systems}
\label{subsec-ts}
As modelling formalism, we use \emph{Transition Systems} (TS). They are a particular variant 
of \emph{Finite State Automata} which allow to describe adequately both hardware and software systems. 
They are defined over infinite runs, and they do not have a set of final states. 
Formally, a TS is a tuple ($S, Act, \rightarrow, I, AP, L$), where 
\begin{itemize}
    \item $S$ is a set of \emph{states},
    \item $Act$ is a set of \emph{actions},
    \item $\longrightarrow\,\subseteq S \times Act \times S$ is a \emph{transition relation},
    \item $I \subseteq S$ is a set of \emph{initial states}.
    \item $AP$ is a set of \emph{atomic propositions}, and 
    \item $L : S \rightarrow 2^{AP}$ is a \emph{labelling function}.
\end{itemize}
Actions are used to specify how the system evolves from one state to another. The labelling function 
maps every state to the set of atomic propositions holding in that state. The initial state is chosen 
nondeterministically between all states $\in I$.
We adopt a \textbf{state-based} approach: we consider (and want to verify) the labels in the state sequence 
of a run of the TS, and abstract from actions, which are of no use in our verification algorithm. 

Note that, for simplicity sake, we consider only TS with no terminal states, i.e., every state has at least 
one outgoing edge. While this prevents some technical problems from occurring, it is not a limit to the 
expressive power of TS: for every state $s$ without outgoing edge, define a transition to a sink state 
$s_ {sink}$, and then define a self transition from $s_ {sink}$ to itself.

\subsubsection*{Resources}
\cite[Paragraph 2.1]{BaKa}

\subsubsection*{Task 1}
Define:
\begin{itemize}
    \item a suitable plain-text representation of TS such that TS written in this representation
          can be passed as input to your tool, and
    \item a data type to represent them. 
    \item the type of the set of atomic propositions that can be used to label states of the Transition System.
        These are usually either a description of the state (e.g., OFF for a system that describes a lightbuld) 
        or a property that holds in the state (e.g. $nsoda == 0$ for a system that 
        describes the functioning of a soda vending machine). We refer to 
        the example in Section \ref{subsec:example}
\end{itemize} 
Implement: 
\begin{itemize}
    \item A parsing function from the plain-text representation of TS to the data type.
\end{itemize}
Take care of making sure that there are no terminal states, that there is at least an initial state, 
and that your formalisation of the set of atomic proposition is respected. The parsing function should 
abort when it encounters a non well formed Transition System.

You are allowed to choose one of the parsing approaches presented in the lecture or 
use an external monadic parsing library from Hackage. Document your choice.

We require that a state is always labelled with itself 
(i.e., $s_i \in L(s_i)$, which implies $S \subset AP$). This does not mean that the atomic propositions 
we are considering are only state identifiers. As introduced earlier, a state may be labelled with different 
types of properties depending on the context: it will be up to you to define a suitable type to make your 
program be able to encode and deal with as many different situations as possible.



\subsection{Preliminaries - Computational Tree Logic}
\label{subsec-ctl}
To express properties to verify on Transition Systems, we consider a temporal extension of propositional logic, i.e., 
the introduction of temporal modalities on top of propositional logic. In particular, the temporal
modalities we consider are $\ocircle$ (pronounced ``next'') and $\luntilbase$ (pronounced ``until'').
The atomic proposition $a \in AP$ stands for the state label $a$ in a TS.

\subsubsection*{Syntax}
Given a set $AP$ of atomic propositions, with $a \in AP$, LTL formulas follow the following syntax: 
\begin{align*}
    &\; \varphi ::= \text{true} \mid a \mid \varphi_1 \land \varphi_2 \mid \neg \varphi \mid \lnext{\varphi} \mid \lluntil{\varphi_1}{\varphi_2}
\end{align*}

In addition, we introduce the following \emph{derived} Boolean operators: 
\begin{align*}
    &\; \varphi_1 \lor \varphi_2 \equiv \neg (\neg \varphi_1 \land \varphi_2) \\
    &\; \varphi_1 \rightarrow \varphi_2 \equiv \neg \varphi_1 \lor \varphi_2 \\
    &\; \varphi_1 \leftrightarrow  \varphi_2 \equiv (\varphi_1 \rightarrow \varphi_2) \land (\varphi_2 \rightarrow \varphi_1) \\
    &\; \varphi_1 \oplus  \varphi_2 \equiv (\varphi_1 \land \neg \varphi_2) \lor (\varphi_2 \land \neg \varphi_1)\\
\end{align*}

Likewise, we derive some well-known temporal modalities (pronounced ``eventually'' and ``generally/always", respectively):
\begin{align*}
    &\; \lleven \varphi \equiv \lluntil{\text{true}}{\varphi} \\
    &\; \llglob \varphi \equiv \neg \lleven \neg \varphi \\
\end{align*}

You are required to handle all and only these operators (this excludes the weak until operator, for example).

\subsubsection*{Hint about derived operators}
If your code translates formulas with derived operators into formulas 
with only base operators through these equivalence rules, you will have implemented support of 
derived operators for free.

\subsubsection*{Semantics}
We define the semantics of LTL formulas over a trace of a Transition System ($S, Act, \rightarrow, I, AP, L$). 
Given an infinite sequence of states $s_0s_1s_2 \dots$ (i.e.~a path) of the TS, 
its trace is just the induced infinite sequence of atomic propositions $ \sigma = L(s_0)L(s_1) \dots \in (2^{AP})^{\omega}$.
Let $\sigma = A_0A_1A_2 \dots$. Then $\vDash$ (pronounced ``satisfies") is defined by:
\begin{align*}
    &\; \sigma \vDash \text{ true} \\
    &\; \sigma \vDash a \text{ iff } a \in A_0 \\
    &\; \sigma \vDash \varphi_1 \land \varphi_2 \text{ iff } \sigma \vDash \varphi_1 \text{ and } \sigma \vDash \varphi_2 \\
    &\; \sigma \vDash \neg \varphi \text{ iff } \sigma \nvDash \varphi \\
    &\; \sigma \vDash \lnext{\varphi} \text{ iff } \sigma [A_1 \dots] \dots \vDash \varphi \\
    &\; \sigma \vDash \lluntil{\varphi_1}{\varphi_2} \text{ iff } \exists j \geqslant 0 .  A_j \dots \vDash \varphi_2 \text{ and } A_i \dots \vDash \varPhi_1 \text{, for all } 0 \leqslant  i < j
\end{align*}
An LTL formula $\varphi$ holds in a path $\pi$ if it holds for $trace(\pi)$. 
IT holds for a state $s$ if it holds for all paths starting in $s$.
It holds for a TS if and only if it holds for all the infinite paths 
starting in an initial state of the TS, or, in other words, if it holds for all initial states.

\subsubsection*{Task 2}
Define:
\begin{itemize}
    \item a suitable plain-text representation of LTL formulas such that formulas written in this representation can be passed as input to your tool, and
    \item a data type to represent them. 
    \item the type of the set of atomic propositions that can be used in the formulas \textcolor{red}{[see above, more detail required?]}.
\end{itemize}
Implement: 
\begin{itemize}
    \item A parsing function from the plain-text representation to the data type.
\end{itemize}
Note that the Atomic Propositions of LTL formulas must match the Atomic Proposition that we have previously 
defined and implemented to label the states of the Transition System. The parsing function should abort 
when it encounters a non well formed LTL formula.

You are allowed to choose one of the parsing approaches presented in the lecture or 
use an external monadic parsing library from Hackage. Document your choice.

\subsubsection*{Resources}
\cite[Paragraph 5.1 (in particular 5.1.1 and 5.1.2)]{BaKa}

\subsection{Preliminaries - The overall Model Checking algorithm}
\label{subsec-mca}
\begin{algorithm}[H]
    \caption{Automaton Based LTL Model Checking}
    \label{alg:mc}
    \hspace*{\algorithmicindent} \emph{Input}: finite transition system TS and LTL formula $\varphi$ (both over $AP$) \\
    \hspace*{\algorithmicindent} \emph{Output}: ``yes'' if $TS \vDash \varphi$; otherwise, ``no''
    \begin{algorithmic}[1]
    \State \textbf{Module 1}: Construct an NBA $\mathcal{A}_{\neg \varphi}$ such that $\mathcal{L}_{\omega}(\mathcal{A}_{\neg \varphi}) = $ Words($\neg \varphi$) (refer to \cite{BaKa} for details!)
    \State \textbf{Module 2}: Construct the product transition system $TS \oplus \mathcal{A}$; determine if there exists 
                a path $\pi$ in $TS \oplus \mathcal{A}$ satisfying the acceptance condition of $\mathcal{A}$
            \textcolor{red}{[$\oplus$ was introduced in Section \ref{subsec-ltl} as LTL operator; here it is
            used as operator on automata: some hint seems required.]}
    \If{there exists such a path}
        \State return ``no'' 
    \Else 
        \State return ``yes''
    \EndIf
    \end{algorithmic}
\end{algorithm}
  
It is up to you to decide how to combine the two plain text representations of the inputs (the TS and the formula), 
and how to provide them to the Model Checker via some command-line arguments. Any potential issue with 
command line arguments must be treated adequately (e.g., missing arguments, too many arguments, wrong arguments, \dots).

The results of a model check query should be printed on the CLI (command line interface), together with some additional 
information you find useful.

\subsection{Module 1 - Automaton Construction from an LTL formula}
\label{subsec-m1}
In this module, you will have to build a \emph{Generalized Nondeterministic Büchi Automaton}(GNBA) 
that recognizes all and only the traces that satisfy an LTL formula $\varphi$. The algorithm you have to follow 
is given in \cite[Section 5.2]{BaKa}. 
We will now outline the main definitions and steps involved in the construction.

\subsubsection*{Generalized NBA}
A GNBA is a tuple $\mathcal{G} := (Q, \Sigma, \delta, Q_0, \mathcal{F})$ where:
\begin{itemize}
    \item $Q$ is the (finite) set of states.
    \item $\Sigma$ is the alphabet (and in our case it will always be the set $2^{AP}$).
    \item $Q_0 \subseteq Q$ is the set of initial states.
    \item $\delta : Q \times 2^{Q}$ is the (nondeterministic) transition relation 
    \item $\mathcal{F}$ is a subset of $2^{Q}$.
\end{itemize}
The definition of a GNBA is the same as the definition of a nondeterministic Buechi Automaton, apart from $\mathcal{F}$.
$\mathcal{F}$ is the so called \emph{set of acceptance sets}. The accepted language $\mathcal{L}_{\omega}(\mathcal{G})$
consists of all $\omega$-words that have at least one infinite run $q_0q_1 \dots$ in $\mathcal{G}$ such that 
for each acceptance set $F \in \mathcal{F}$ there are infinitely many indices $i$ with $q_i \in F$.

\subsubsection*{Closure of a LTL formula $\varphi$}
The \emph{closure} of a LTL formula $\varphi$ is the set $Cl(\varphi)$ which contains all subformulas $\psi$ 
of $\varphi$ as well as their negations. Formally , $Cl(\varphi)$ is the smallest set such that: 
\begin{itemize}
    \item $\varphi \in Cl(\varphi)$,
    \item $a \in AP, a \in Cl(\varphi)$, for all $a \in AP$,
    \item if $\psi \in Cl(\varphi)$, and $\psi \neq \neg \theta$, then $\neg \psi \in Cl(\varphi)$ (we identify $\not \not \psi$ with $\psi$),
    \item if $\neg \psi \in Cl(\varphi)$, then $\psi \in Cl(\varphi)$,
    \item if $\psi \land \theta \in Cl(\varphi)$, then $\psi, \theta \in Cl(\varphi)$,
    \item if $\lnext{\psi} \in Cl(\varphi)$, then $\psi \in Cl(\varphi)$,
    \item if $\lluntil{\psi}{\theta} \in Cl(\varphi)$, then $\psi, \theta \in Cl(\varphi)$.
\end{itemize}

\subsubsection*{Elementary set of formulas}
A set $B \subseteq Cl(\varphi)$ is called elementary if:
\begin{enumerate}
    \item it is \emph{consistent} with respect to propositional logic, i.e., for all 
            $\varphi_1 \land \varphi_2, \psi \in Cl(\varphi)$:
            \begin{itemize}
                \item $\varphi_1 \land \varphi_2 \in B$ if and only if $\varphi_1 \in B$ and $\varphi_2 \in B$.
                \item $\psi \in B$ implies $\neg \psi \notin B$ 
                \item true $\in Cl(\varphi)$ implies true $\in Cl(\varphi)$.
            \end{itemize}
    \item it is \emph{locally consistent} with respect to the until operator, i.e., for all 
            $\lluntil{\varphi_1}{\varphi_2} \in Cl(\varphi)$:
            \begin{itemize}
                \item $\varphi_2 \in B$ implies $\lluntil{\varphi_1}{\varphi_2} \in B$
                \item $\lluntil{\varphi_1}{\varphi_2} \in B$ and $\varphi_2 \notin B$ implies $\varphi_1 \in B$.
            \end{itemize}
    \item it is \emph{maximal} i.e., for all $\psi \in Cl(\varphi)$:
            \begin{itemize}
                \item $\psi \notin B$ implies $\neg \psi \in B$.
            \end{itemize}
\end{enumerate}

\subsubsection*{GNBA for LTL}
Given a LTL formula $\varphi$ over AP, we define as follows the GNBA $\mathcal{G}_{\varphi}$ which recognizes all
and only the strings over the alphabet $2^{AP}$ that satisfy $\varphi$.

$\mathcal{G}_{\varphi} := (Q, 2^{AP}, \delta, Q_0, \mathcal{F})$ such that: 
\begin{itemize}
    \item $Q \subseteq 2^{Cl(\varphi)}$ is the set of all the elementary sets of formulae $B \subseteq Cl(\varphi)$,
    \item $Q_0 = \{ B \in Q \mid \varphi \in B\}$,
    \item $\mathcal{F} = \{ F_{\lluntil{\varphi_1}{\varphi_2}} \mid \lluntil{\varphi_1}{\varphi_2} \in Cl(\varphi) \} $, where 
            \begin{itemize}
                \item $F_{\lluntil{\varphi_1}{\varphi_2}} = \{ B \in Q \mid \lluntil{\varphi_1}{\varphi_2} \notin B$ or $\varphi_2 \in B \}$.
            \end{itemize}
\end{itemize}

The transition  relation $\delta : Q \times 2^{AP} \rightarrow 2^Q$ is defined as follows;
(given an elementary set $B$, i.e., a state of the automaton, and a set of $AP$ A):
\begin{itemize}
    \item if $A \neq B \cap AP$, then $\delta(B,A) = \varnothing$,
    \item if $A = B \cap AP$, then $\delta(B,A)$ is the set of all elementary sets of formulas $B^{'}$ such that 
            \begin{enumerate}
                \item for all $\lnext{\psi} \in Cl(\varphi)$, $\lnext{\psi} \in B$ if and only if $\psi \in B^{'}$,
                \item for all $\lluntil{\varphi_1}{\varphi_2} \in Cl(\varphi)$, 
                
                
                    \begin{center}
                        $\lluntil{\varphi_1}{\varphi_2} \in B$ if and only if $(\varphi_2 \in B \lor (\varphi_1 \in B \land \lluntil{\varphi_1}{\varphi_2} \in B^{'}))$
                    \end{center}
            \end{enumerate}
\end{itemize}




\subsubsection*{Note 1}
Recall that, in order to prove that the input formula $\varphi$ holds for all initial paths of a TS, we have 
to verify the TS against the automaton for the \textbf{negation} of the input formula, i.e., an automaton-representation 
for the negated formula $\neg \varphi$.

\subsubsection*{Note 2}
While in module 2 the product transition system is build upon a Nondeterministic Büchi Automaton (NBA), we note 
than a GBA and a NBA differ only for the acceptance condition. This difference can be hidden in the 
data type you use to represent the automata (e.g., through some higher-order functions), 
therefore it is not needed to implement the transformation ``GNBA $\leadsto$ NBA'' given by Theorem 4.56, as indicated 
by the textbook.

\subsection{Module 2 - Fair-cycle Detection of the product transition System}
\label{subsec-m2}
\subsubsection*{Generating the product Transition System}
This task consists of implementing the generation of the product transition system $TS \oplus \mathcal{A}$
starting from the input TS and the (generalized) NBA $\mathcal{A}$ built from the input formula in module 1.
For this purpose, we refer you to the product construction of \cite[Section 4.4.1]{BaKa}.

\subsubsection*{Detecting Fair cycles}
This task consists of implementing an exploration algorithm for the transition relation of the product 
automaton. The goal is to find a so called \emph{fair} cycle, i.e., a cycle which satifies the acceptance 
condition of the underlying NBA. The existance of such cycle, and the reachability of such cycle from an 
initial state, allows us to conclude that there exist an infinite path of the TS which does not satisfy the input 
formula $\varphi$. Two algorithms for this purpose are presented in \cite[Section 4.4.2]{BaKa}.

\subsubsection*{Note}
You have to choose an approach to handle the global variables of the fair-cycle detection algorithm. 
There are two main approaches available (but you may come up with a new one):
\begin{itemize}
    \item continuation: the exploration function calls itself recursively with its updated global variables 
            and a new state to be explored 
    \item monadic: use the state monad presented in the lecture or the state monad 
            as defined in the \href{https://hackage.haskell.org/package/transformers}{\texttt{transformers}} library.
\end{itemize}

\subsection{Test Suite}
Projects of this size profit from an automatic test-suite. 
Write a test-suite for the major components of the project using one of the following frameworks:

\begin{itemize}
\item \href{https://hackage.haskell.org/package/hspec}{\texttt{hspec}}, a tutorial can be found \href{https://hspec.github.io/}{\texttt{here}}
\item \href{https://hackage.haskell.org/package/tasty}{\texttt{tasty}}
\item \href{https://hackage.haskell.org/package/HTF}{\texttt{HTF}}
\item \href{https://hackage.haskell.org/package/HUnit}{\texttt{HUnit}}
\end{itemize}

As before, it is encouraged to utilise external libraries for writing tests.

It is required to write at least three unit tests per major component, where major components are:

\begin{itemize}
\item MiniCheck automaton construction
\item MiniCheck cycle detection
\end{itemize}

To test the automaton costruction function, a recommended way is to run some strings on the automaton, 
and verify that the acceptance of the string is as expected.

To test the cycle detection algorithm, a smart way is to implement the bonus Section \ref{sec::bonus1}
\todo[inline]{What can we do with QuickCheck on the model Checker?}

\subsection{Example} \label{subsec:example}
\todo[inline]{write me}

\section{MINI Extensions}
This section describes some extensions to MiniCheck. Each extension is worth the given amount of points. 
Note that none of the described extensions are necessary for a positive grade.

\subsection{Parsing MINI Programs (100 P)}
With this extension, you are required to extend the modelling power of MiniCheck targeting 
software verication. While TS are good for expressing hardware models, they may be too low-level 
to model software programs. To help the user of your version of MiniCheck, you will implement an 
automated translation procedure for MINI programs into TS.

\todo[inline]{write me}

\todo[inline]{Shall we include also While loops?}

\subsubsection*{A Note about terminal states}
\todo[inline]{write me}



\subsection{CTL model checking (100 P)}
With this extension, you are required to extend the verification power of MiniCheck targeting a new class 
of properties, those based on a \emph{branching} notion of time. Indeed, while in LTL a property for a state 
always range over all possible paths starting from that state, in some situations we would like to reason only
about some of such paths. With this approach, the notion of time corresponds to that of an infinite tree of states, 
instead of an infinite sequence. Infact, branching time refers to the fact that at each moment there may be 
several different possible futures. By fixing a choice of a state at every subtree, we get one of all \emph{possible}
futures. Each traversal of the tree starting in its root represent a single path. The tree rooted
at state $s$ thus represents all possible infinite computations in the transition system that
start in $s$.

Computation Tree Logic (CTL) thus allows to express properties for \emph{some} or \emph{all} computations 
that start in a state. For this purpose, it features two operators: an existential path quantifier ($\exists$) 
and a universal path quantifier ($\forall$). 

As modelling formalism, you are required to use the same as in the core modules.

\subsubsection*{CTL Syntax}
As  in LTL, at the bottom of CTL there are atomic propositions $AP$ which represent the labels for the states in a TS.
\begin{align*}
    &\; \emph{(state) formulas} &\; \Phi ::= \text{true} \mid a \mid \Phi_1 \land \Phi_2 \mid \neg \Phi \mid \exists \varphi \mid \forall \varphi \\
    &\; \emph{path formulas}    &\; \Phi ::= \lnext{\Phi} \mid \lluntil{\Phi_1}{\Phi_2}
\end{align*}
Greek capital letters denote CTL (state) formulas, whereas lowercase Greek letters denote CTL path formulas. 
A well defined CTL formula is a CTL state formula.

As in LTL, you are required to implement also the derived Boolean operators and the temporal modalities ``Eventually'' and ``Always''.
\todo[inline]{add the translation of this formulas}

\subsubsection*{CTL Semantics}
Given atomic proposition $a \in AP$, $TS = (S, Act, \rightarrow, I, AP, L)$, state $s \in S$, CTL state formulas 
$\Phi, \Psi$, CTL path formula $\varphi$, the semantics of CTL is defined in terms of the following 
satisfaction relation $\vDash$ for state $s$ (compare it with the LTL satisfaction relation, which was defined over a trace $\sigma$):
\begin{align*}
    &\; \sigma \vDash \text{true} \\
    &\; \sigma \vDash a \text{ iff } a \in L(s) \\ 
    &\; \sigma \vDash \neg \Phi \text{ iff not } s \vDash \Phi \\
    &\; \sigma \vDash \Phi \land \Psi \text{ iff } (s \vDash \Phi) \text{ and } (s \vDash \Psi) \\
    &\; \sigma \vDash \exists \varphi \text{ iff } \pi \vDash \varphi \text{ for some } \pi \in Paths(s) \\ 
    &\; \sigma \vDash \forall \varphi \text{ iff } \pi \vDash \varphi \text{ for all } \pi \in Paths(s) \\ 
\end{align*}

Given a path $\pi$, $\vDash$ is defined for path formulas as follows: 
\begin{align*}
    &\; \pi \vDash \lnext{\Phi} \text{ iff } \pi[1]  \vDash \Phi \\ 
    &\; \pi \vDash \lluntil{\Phi}{\Psi} \text{ iff } \exists j \geqslant 0. (\pi[j]  \vDash \Psi \land (\forall 0 \leqslant k < j. \pi[k]  \vDash \Phi))
\end{align*}

A TS satisfies CTL formula $\Phi$ if and only if $\Phi$ holds for all initial states.

\subsubsection*{Task}
Define:
\begin{itemize}
    \item a suitable plain-text representation of CTL formulas such that formulas written in this representation can be passed as input to your tool, and 
    \item a data type to represent them.
    \item the type of the set of atomic propositions ($APs$) that can be used in the formulas (the same reasoning for LTL $APs$ applies).
\end{itemize}


\subsubsection*{Model Checking procedure}
The model checking procedure for CTL formulas differs completely from LTL verification. 
It's essentially based on a bottom-up traversal of the parse tree of the formula at hand, 
and it is considered way more efficient and straightforward, since it does not involve any notion of 
corresponding automaton for the input formula. Instead, given a TS and a CTL formula $\Phi$, to verify 
whether TS $\vDash \Phi$, we establish whether $\Phi$ is valid in each initial state $s$ of TS. 
Therefore, the procedure is roughly composed of two steps: 
\begin{itemize}
    \item computing the set $Sat(\Phi)$ of all states satisfying $\Phi$ (recursively), and
    \item checking whether all initial states $s \in I$ belong to $Sat(\Phi)$; 
\end{itemize}
In other words, TS $\vDash \Phi$ if and only if $I \subseteq Sat(\Phi)$.


The following algorithm sketches the procedure. 
\label{subsec-CTLmca}
\begin{algorithm}[H]
    \caption{CTL Model Checking}
    \label{alg:CTLmc}
    \hspace*{\algorithmicindent} \emph{Input}: finite transition system TS and CTL formula $\Phi$ (both over $AP$) \\
    \hspace*{\algorithmicindent} \emph{Output}: ``yes'' if $TS \vDash \Phi$; otherwise, ``no''
    \begin{algorithmic}[1]
    \Function{$SatFun$}{$\phi$}
        \If{$\phi$ contains state subformulas}
            \State $Sat(\psi_1) = SatFun(\psi_1)$ 
            \State $Sat(\psi_2) = SatFun(\psi_2)$ 
            for children nodes $\psi_1, \psi_2$ of the parse tree of $\phi$, the so called \emph{maximal proper subformulas}
            \State combine $Sat(\psi_1), Sat(\psi_2)$ depending on the operator of $\phi$ ($\land, \exists\lnext, \exists\mathbin{\mathcal{U}}, \exists\llglob$).
        \Else
            \State compute directly the set $Sat(\phi)$.
        \EndIf
        \State return $Sat(\phi)$.
    \EndFunction
    \State return $I \subseteq Sat(\Phi)$.
    \end{algorithmic}
\end{algorithm}

\subsubsection*{Definition of $SatFun$}


\subsubsection*{Task}


\section{Bonus Task: Related LTL problems (10P)} \label{sec::bonus1}

\subsection{Satisfiability Checking}
On the \code{--sat} flag, the Model Checker constructs the FSA starting from the input formula
and perform the fair-cycle detection module on \textbf{this automaton only}. 
This procedure amounts at verifying whether the formula is satisfiable by any string. 

\subsection{Validity Checking}
On the \code{--val} flag, the Model Checker constructs the FSA starting from \textbf{negation of} 
the input formula and perform the fair-cycle detection module on \textbf{this automaton only}. 
Then, it must return the negation of the result.
This procedure amounts at verifying whether the formula is valid, i.e., it is satisfied by any string. 

\subsubsection*{Note}
It is up to you to decide whether changing the format of the input file(s)
(e.g., by forbidding to include the Transition System in the file) 
that can go in hand with the \code{--sat} and \code{--val} flags.

\subsubsection*{Resources}
\cite[Paragraph 5.2.2]{BaKa}

\section{Bonus Task - Returning a Counterexample for LTL properties (10 P)} \label{sec::bonus2}
On the \code{--ce} flag, the Model Checker returns a Counterexample (CE) if the formula is 
not satisfied. A CE is a sequence of states of the TS of the form $s_0s_1 \dots (s_n \dots s_m )^{\omega}$
such that $L(s_0)L(s_1) \dots (L(s_n) \dots L(s_m) )^{\omega}$ does not satisfy the input property $\varphi$.

\section{Bonus Task: Project Management (25P)}

There is more to a successful project than just writing code. 
Usually, you also need to write proper documentation, distribute it, etc...

In this section, you will try some project management mechanisms for Haskell: 
In particular, you will provide documentation for your program, 
find the coverage of your test-suite and learn more about basic profiling with GHC.

\subsection{Command-Line Interface}

The program so far only has very rudimentary argument parsing, allowing a single filepath.
However, anyone who did not write this program has no idea about how to invoke the Model Checker correctly,
thus, we want to have a proper command-line interface

\subsubsection*{Implementation Suggestions}

Common libraries for such tasks are \href{https://hackage.haskell.org/package/optparse-applicative}{\texttt{optparse-applicative}} 
and \href{https://hackage.haskell.org/package/cmdargs}{\texttt{cmdargs}} but it is also valid to not use any libraries at all 
and design your own solution.

\subsubsection*{Required Flags}

The program should be able to understand the following flags:

\begin{itemize}
\item On \code{-h}/\code{--help}, a help message should be displayed, explaining how the program can be invoked correctly.
\item On \code{--ts}, the input transition system
\item On \code{--extensions}, a list of supported MINI extensions is printed.
\item Other flags as you see appropriate. (optional. not graded)
\end{itemize}

\subsection{Documentation}

Document the most important types and functions of your project \href{https://haskell-haddock.readthedocs.io/en/latest/markup.html}{\texttt{haddock}}-conformly and provide the documentation via HTML.

Helpful commands:

\begin{itemize}
\item \code{cabal haddock} for building the documentation and inspecting it locally.
\item \code{cabal haddock --haddock-for-hackage} for building a \code{.tar.gz} containing the documentation.
\item \code{stack haddock --open}: builds documentation and opens it in the browser upon completion.
\end{itemize}

\subsection{Test Coverage}

Generate the test-coverage of your program's test-suite.
Discuss your findings and investigate any unexpected results.

Helpful commands:

\begin{itemize}
\item \code{cabal test --enable-coverage}
\item \code{stack test --coverage}
\end{itemize}

\subsection{Profiling}

Being able to profile your code is of great importance in real-world projects. Thus, we want you to experiment with some profiling in Haskell.

To do that, you might have to build your project in profiling mode:

\begin{itemize}
\item \code{cabal build --enable-profiling}
\item \code{stack build --profile}
\end{itemize}

Then you can pass RTS arguments to the GHC program to obtain run-time information, such as which function you spend the most amount of time in, etc...

Refer to the GHC documentation for the exact \href{https://downloads.haskell.org/ghc/latest/docs/html/users_guide/profiling.html#profiling-memory-usage}{\texttt{profiling flags}} to obtain relevant information.

Answer the following questions:

\begin{itemize}
\item What is the memory usage over time?
\item What is the peak memory usage?
\item Which function is the most time spent in?
\item Which type requires the most amount of memory?
\end{itemize}

\section{Submission artefacts}

You should submit a zip-archive containing all project source files and a PDF with detailed project documentation in your group submission directory.

\subsection{Project Implementation}

The project should be written as a \code{cabal} or \code{stack} project consisting of multiple modules.

\subsection{Test Suite}

Unit tests and property tests need to be submitted as well, and it must be possible to run the whole test-suite with either \code{cabal test} or \code{stack test}.

\subsubsection*{Project Documentation}

The project documentation pdf should cover at least these topics and explain your choices.
\todo[inline]{Add some appropriate questions here}
\begin{itemize}
\item Which project build tool is used for the project? (\texttt{cabal} or \texttt{stack})
\item Which GHC version is used?
\item How can the program binary be built? How can it be run?
\item Which libraries are included as dependencies and which Haskell language extensions are enabled?
\item Which Framework and libraries are used for writing tests?
\item Which MiniCheck extensions are implemented?
\item How is the functionality partitioned into different modules?
\item How do you test your program? Which parts are the focus of your tests? Do there exist parts of the code that cannot be tested?
\item Are there known issues and limitations of your program?
\end{itemize}

\vspace*{1cm}

\printbibliography




\end{document}


